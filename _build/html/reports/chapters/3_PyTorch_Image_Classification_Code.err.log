Traceback (most recent call last):
  File "/Users/Y/miniconda3/envs/docs/lib/python3.11/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/Users/Y/miniconda3/envs/docs/lib/python3.11/site-packages/nbclient/client.py", line 1305, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/Y/miniconda3/envs/docs/lib/python3.11/site-packages/jupyter_core/utils/__init__.py", line 166, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/Y/miniconda3/envs/docs/lib/python3.11/asyncio/base_events.py", line 653, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/Users/Y/miniconda3/envs/docs/lib/python3.11/site-packages/nbclient/client.py", line 705, in async_execute
    await self.async_execute_cell(
  File "/Users/Y/miniconda3/envs/docs/lib/python3.11/site-packages/nbclient/client.py", line 1058, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/Users/Y/miniconda3/envs/docs/lib/python3.11/site-packages/nbclient/client.py", line 914, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import pandas as pd
import torch
from torch.utils.data import DataLoader, Dataset
import torchvision.transforms as transforms
from torchvision import models
from PIL import Image
import time
from sklearn.preprocessing import LabelEncoder

# Hyperparameters
EPOCHS = 5
BATCH_SIZE = 16

# Check that MPS is available
if not torch.backends.mps.is_available():
    if not torch.backends.mps.is_built():
        print("MPS not available because the current PyTorch install was not "
              "built with MPS enabled.")
    else:
        print("MPS not available because the current MacOS version is not 12.3+ "
              "and/or you do not have an MPS-enabled device on this machine.")
    print("CPU being used.")
    device = torch.device("cpu")
else:
    print("Apple MPS being used.")
    device = torch.device("mps:0")

# Initialize label encoder for the concatenated label
concat_encoder = LabelEncoder()

# Start the timer
start_time = time.time()

# Read the Excel file into a DataFrame
df = pd.read_excel('US_hip_dataset.xlsx')

# Create a concatenated label
df['Concat_Label'] = df['US probe orientation'] + '_' + df['Anatomical location']

# Fit the encoder on the new concatenated label
concat_encoder.fit(df['Concat_Label'])

# Filter based on Sample ID for training and testing
train_df = df[df['Sample ID'] == 10001]#.sample(100)
test_df = df[df['Sample ID'] == 10002]#.sample(100)


# Custom UltrasoundDataset class
class UltrasoundDataset(Dataset):
    def __init__(self, dataframe, transform=None):
        self.dataframe = dataframe
        self.transform = transform

    def __len__(self):
        return len(self.dataframe)

    def __getitem__(self, idx):
        img_name = self.dataframe.iloc[idx]['File location']
        image = Image.open(img_name).convert('RGB')
        if self.transform:
            image = self.transform(image)

        # Encode concatenated label to integer
        concat_label = concat_encoder.transform([self.dataframe.iloc[idx]['Concat_Label']])[0]

        return image, concat_label  # Return concatenated label


# Data transformations
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
])

# Initialize datasets and dataloaders
train_dataset = UltrasoundDataset(dataframe=train_df, transform=transform)
train_loader = DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)
test_dataset = UltrasoundDataset(dataframe=test_df, transform=transform)
test_loader = DataLoader(test_dataset, batch_size=BATCH_SIZE, shuffle=False)

# Initialize the model
model = models.resnet18(weights=models.ResNet18_Weights.IMAGENET1K_V1).to(device)

# Loss and optimizer
criterion = torch.nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

# Training loop
for epoch in range(EPOCHS):
    print("Currently in epoch " + str(epoch + 1))
    for image, concat_label in train_loader:
        image = image.to(device)
        concat_label = concat_label.to(device)
        optimizer.zero_grad()
        outputs = model(image)
        loss = criterion(outputs, concat_label)
        loss.backward()
        optimizer.step()
    current_time = time.time()
    print(f"Elapsed time since starting: {current_time - start_time:.2f} seconds")

# Testing the model
model.eval()
correct = 0
total = 0
model.to(torch.device("cpu"))
with torch.no_grad():
    for image, label in test_loader:
        # image = image.to(device)
        # label = label.to(device)
        outputs = model(image)
        _, predicted = torch.max(outputs.data, 1)
        total += label.size(0)
        correct += (predicted == label).sum().item()

print(f'Accuracy of the model on the test images: {int(100 * correct / total)}%')

# Stop the timer
end_time = time.time()

# Print the elapsed time
print("Finished Training")
print(f"Elapsed time: {end_time - start_time:.2f} seconds")
------------------


[0;31m---------------------------------------------------------------------------[0m
[0;31mModuleNotFoundError[0m                       Traceback (most recent call last)
Cell [0;32mIn[1], line 2[0m
[1;32m      1[0m [38;5;28;01mimport[39;00m [38;5;21;01mpandas[39;00m [38;5;28;01mas[39;00m [38;5;21;01mpd[39;00m
[0;32m----> 2[0m [38;5;28;01mimport[39;00m [38;5;21;01mtorch[39;00m
[1;32m      3[0m [38;5;28;01mfrom[39;00m [38;5;21;01mtorch[39;00m[38;5;21;01m.[39;00m[38;5;21;01mutils[39;00m[38;5;21;01m.[39;00m[38;5;21;01mdata[39;00m [38;5;28;01mimport[39;00m DataLoader, Dataset
[1;32m      4[0m [38;5;28;01mimport[39;00m [38;5;21;01mtorchvision[39;00m[38;5;21;01m.[39;00m[38;5;21;01mtransforms[39;00m [38;5;28;01mas[39;00m [38;5;21;01mtransforms[39;00m

[0;31mModuleNotFoundError[0m: No module named 'torch'

